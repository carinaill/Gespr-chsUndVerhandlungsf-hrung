\chapter{Implementation}

Your implementation goes here...

\section{Description of the Front End}

\section{Description of the Back End}


\begin{figure}[H]
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwProg{Fn}{function}{:}{}
\Fn{heuristic\_order\_selection\_shift($df\_p, iterator, num\_classes$)}{
\KwData{$df\_p$ is the dataframe in projection space, $iterator$ is the current iteration step, $num\_classes$ is the amount of different classes in the dataset}
\KwResult{$dp$ shift vector, $selected\_class$ to be shifted, calculated $DSC\_value$, calculated $CD\_value$, calculated $total\_dist$}
\tcc{extract star coords and class of data to a new dataframe}
df\_star = df\_p[['X','Y','class']]\;
\tcc{calculate class centroids and save them in a new dataframe}
df\_centroids = df\_star.groupby('class', sort=True).mean().reset\_index()\;
\tcc{calculate coordinates of the central centroid}
central\_centroid = df\_centroids[['X', 'Y']].mean()\;
\tcc{call a function to calculate all distances between centroids}
df\_distances = calc\_centroid\_distances(df\_centroids)\;
\tcc{calculate the distance from each point to its associated centroid}
df\_centroid\_distances = calc\_dist\_p\_to\_assoc\_centroid(df\_centroids, df\_star)\;
\tcc{calculate CD, DSC and total\_dist for result}
CD\_value = df\_centroid\_distances['distance'].sum()\;
DSC\_value = calc\_dsc(df\_centroids, df\_star)\;
total\_dist = df\_distances['distance'].sum()\;
\color{green}
\tcc{find the minimum distance between two class centroids}
min\_dist\_idx = df\_distances['distance'].idxmin()\;
min\_class1 = df\_distances.loc[min\_dist\_idx, 'class1']\;
min\_class2 = df\_distances.loc[min\_dist\_idx, 'class2']\;
\tcc{select the class that is to be shifted}
selected\_class, other\_class = select\_shifting\_class(df\_distances, min\_class1, min\_class2)\;
\color{black}
\tcc{calculate the new shifting vector dp}
dp = calc\_dp(df\_centroids, selected\_class, other\_class, central\_centroid, num\_iter)\;
}
\caption{Minimum Selection Shift - MSS}
\end{algorithm}
\caption{Pseudocode for MSS}
\label{func:mss}
\end{figure}

shown in Figure \ref{func:calc_centroid_distances}.  

\begin{figure}[H]
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwProg{Fn}{function}{:}{}
\Fn{calc\_centroid\_distances($df\_centroids$)}{
\KwData{dataframe $df\_centroids$ with all positions of the centroids in projection space}
\KwResult{dataframe $df\_distances$ with all distances between class centroids}
\tcc{create dataframe for results}
df\_distances = pd.DataFrame(columns=['class1', 'class2', 'distance'], dtype=float)\;
\tcc{index for writing to df\_distances}
idx = 0\;
\tcc{calculate euclidean distance for every combination of centroids}
\For {index in list(combinations(df\_centroids.index, 2))}{    
    p1 = [df\_centroids.loc[index[0], 'X'], df\_centroids.loc[index[0], 'Y']]\;
    p2 = [df\_centroids.loc[index[1], 'X'], df\_centroids.loc[index[1], 'Y']]\;
    df\_distances.loc[idx, 'class1'] = index[0]\;
    df\_distances.loc[idx, 'class2'] = index[1]\;
    df\_distances.loc[idx, 'distance'] = math.dist(p1, p2)\;
    \tcc{increase the index before going through the next iteration}
    idx = idx + 1\;
    }
}
\end{algorithm}
\caption{Function calc\_centroid\_distances}
\label{func:calc_centroid_distances}
\end{figure}



\begin{figure}[H]
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwProg{Fn}{function}{:}{}
\Fn{handle\_penalty\_counter($cnt, DSC\_o, DSC\_n, td\_o, td\_n, CD\_o, CD\_n$)}{
\KwData{counter $cnt$ for the current penalty \(\tau\), old and new values for $DSC$, $TD$ and $CD$ to compare towards termination criteria}
\KwResult{new value $cnt$ for \(\tau\)}
\If{$DSC\_n \leq DSC\_o$ \tcc{DSC decreased}}{
    $cnt = cnt + 1$ 
    }
\If{$td\_n \leq td\_o$ \tcc{or td decreased}}{
    $cnt = cnt + 1$
    }
\If{$CD\_n \geq CD\_o$ \tcc{or CD decreased}}{
    $cnt = cnt + 1$
    }
\If{$DSC\_n > DSC\_o$ \tcc{DSC increased}}{
    $cnt = 0$
    }
\tcc{DSC did not change and CD decreased or td increased}
\If{$(DSC\_n == DSC\_o) \ \& \ ((CD\_n < CD\_o) \mid (td\_n > td\_o))$}{
    $cnt = 0$
    }
\If{$(CD\_n < CD\_o) \ \& \ (td\_n > td\_o)$\tcc{CD decreased and td increased}}{ 
    $cnt = 0$
}
}
\end{algorithm}
\caption{Function handle\_penalty\_counter}
\label{func:handle_penalty_counter}
\end{figure}